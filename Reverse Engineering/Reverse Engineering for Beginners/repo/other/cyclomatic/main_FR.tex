\section{Complexité cyclomatique}

Ce terme est utilisé pour mesurer la complexité d'une fonction.
Les fonctions complexes sont souvent un fléau, car elles sont difficiles à
maintenir, difficiles à tester, etc.

Il y a plusieurs heuristiques pour la mesurer.

Par exemple, on trouve dans la façon de coder du noyau
Linux\footnote{\url{https://www.kernel.org/doc/html/v4.10/process/coding-style.html}}:

\begin{framed}
\begin{quotation}
Now, some people will claim that having 8-character indentations makes the code move too far to the right, and makes it hard to read on a 80-character terminal screen. The answer to that is that if you need more than 3 levels of indentation, you’re screwed anyway, and should fix your program.

...

Functions should be short and sweet, and do just one thing. They should fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, as we all know), and do one thing and do that well.

The maximum length of a function is inversely proportional to the complexity and indentation level of that function. So, if you have a conceptually simple function that is just one long (but simple) case-statement, where you have to do lots of small things for a lot of different cases, it’s OK to have a longer function.

However, if you have a complex function, and you suspect that a less-than-gifted first-year high-school student might not even understand what the function is all about, you should adhere to the maximum limits all the more closely. Use helper functions with descriptive names (you can ask the compiler to in-line them if you think it’s performance-critical, and it will probably do a better job of it than you would have done).

Another measure of the function is the number of local variables. They shouldn’t exceed 5-10, or you’re doing something wrong. Re-think the function, and split it into smaller pieces. A human brain can generally easily keep track of about 7 different things, anything more and it gets confused. You know you’re brilliant, but maybe you’d like to understand what you did 2 weeks from now.
\end{quotation}
\end{framed}

Dans le JPL Institutional Coding Standard for the C Programming Language%
\footnote{\url{https://yurichev.com/mirrors/C/JPL_Coding_Standard_C.pdf}}:

\begin{framed}
\begin{quotation}
Functions should be no longer than 60 lines of text and define no more than 6 parameters.

A function should not be longer than what can be printed on a single sheet of paper in a standard reference format with one line per statement and one line per declaration. Typically, this means no more than about 60 lines of code per function. Long lists of function parameters similarly compromise code clarity and should be avoided.

Each function should be a logical unit in the code that is understandable and verifiable as a unit. It is much harder to understand a logical unit that spans multiple screens on a computer display or multiple pages when printed. Excessively long functions are often a sign of poorly structured code.
\end{quotation}
\end{framed}

Revenons maintenant à la complexité cyclomatique.

Sans plonger profondément dans la théorie des graphes: il y a des blocs de base
et des liens entre eux.
Par exemple, voici comment \IDA montre les \ac{BB}s et les liens (avec des flèches).
En appuyant sur la barre d'espace, vous verrez ceci: \myref{fig:ex3_IDA_1}.
Chaque \ac{BB} est aussi appelé vertex ou n\oe{} dans la théorie des graphes.
Chaque lien - arête.

Il y a au moins deux façons courantes de calculer la complexité cyclomatique:
1) arêtes - n\oe{}ds + 2
2) arêtes - n\oe{}ds + nombre de sorties (instructions \INS{RET})

Dans l'exemple avec \IDA ici-dessous, il y a 4 \ac{BB}s, donc il y a 4 n\oe{}ds.
Mais il y aussi 4 liens et une instruction de retour.

Plus le nombre est grand, plus votre fonction est complexe et les choses vont de
mal en pis.
Comme vous pouvez le voir, une sortie supplémentaire (instruction return) rend
les choses encore pire, tout comme des liens additionnels entre les n\oe{}ds (un
goto additionnel inclus).

J'ai écris un simple script IDAPython (\url{\RepoURL/other/cyclomatic/cyclomatic.py})
pour la mesurer.
Voici le résultat pour le noyau Linux 4.11 (ses fonctions les plus complexes):

\begin{lstlisting}
1829c0 do_check edges=937 nodes=574 rets=1 E-N+2=365 E-N+rets=364
2effe0 ext4_fill_super edges=862 nodes=568 rets=1 E-N+2=296 E-N+rets=295
5d92e0 wm5110_readable_register edges=661 nodes=369 rets=2 E-N+2=294 E-N+rets=294
277650 do_blockdev_direct_IO edges=771 nodes=507 rets=1 E-N+2=266 E-N+rets=265
10f7c0 load_module edges=711 nodes=465 rets=1 E-N+2=248 E-N+rets=247
787730 dev_ethtool edges=559 nodes=315 rets=1 E-N+2=246 E-N+rets=245
84e440 do_ipv6_setsockopt edges=468 nodes=237 rets=1 E-N+2=233 E-N+rets=232
72c3c0 mmc_init_card edges=593 nodes=365 rets=1 E-N+2=230 E-N+rets=229
...
\end{lstlisting}
( Liste complète: \url{\RepoURL/other/cyclomatic/linux_4.11_sorted.txt} )

Voici le code source de certaines d'entre elles:
\href{https://github.com/torvalds/linux/blob/56868a460b83c0f93d339256a81064d89aadae8e/kernel/bpf/verifier.c\#L2811}{do\_check()},
\href{https://github.com/torvalds/linux/blob/0fcc3ab23d7395f58e8ab0834e7913e2e4314a83/fs/ext4/super.c\#L3358}{ext4\_fill\_super()},
\href{https://github.com/torvalds/linux/blob/86292b33d4b79ee03e2f43ea0381ef85f077c760/fs/direct-io.c\#L1107}{do\_blockdev\_direct\_IO()},
\href{https://github.com/torvalds/linux/blob/bf5f89463f5b3109a72ed13ca62b57e90213387d/arch/x86/net/bpf_jit_comp.c\#L351}{do\_jit()}.

Fonctions les plus complexes du fichier ntoskrnl.exe de Windows 7:

\begin{lstlisting}
140569400 sub_140569400 edges=3070 nodes=1889 rets=1 E-N+2=1183 E-N+rets=1182
14007c640 MmAccessFault edges=2256 nodes=1424 rets=1 E-N+2=834 E-N+rets=833
1401a0410 FsRtlMdlReadCompleteDevEx edges=1241 nodes=752 rets=1 E-N+2=491 E-N+rets=490
14008c190 MmProbeAndLockPages edges=983 nodes=623 rets=1 E-N+2=362 E-N+rets=361
14037fd10 ExpQuerySystemInformation edges=995 nodes=671 rets=1 E-N+2=326 E-N+rets=325
140197260 MmProbeAndLockSelectedPages edges=875 nodes=551 rets=1 E-N+2=326 E-N+rets=325
140362a50 NtSetInformationProcess edges=880 nodes=586 rets=1 E-N+2=296 E-N+rets=295
....
\end{lstlisting}

( Liste complète: \url{\RepoURL/other/cyclomatic/win7_ntoskrnl_sorted.txt} )

Du point de vue du chasseur de bogues, les fonctions complexes sont plus susceptibles
d'avoir des bogues, donc il faut leurs donner une attention particulière.

En lire plus à ce sujet:
\url{https://fr.wikipedia.org/wiki/Nombre_cyclomatique},
\url{https://en.wikipedia.org/wiki/Cyclomatic_complexity},
\url{http://wiki.c2.com/?CyclomaticComplexityMetric}.

Mesure de la complexité cyclomatique dans MSVS (C\#):
\url{https://blogs.msdn.microsoft.com/zainnab/2011/05/17/code-metrics-cyclomatic-complexity/}.

Une paire d'autres scripts Python pour mesurer la complexité dans \IDA:
\url{http://www.openrce.org/articles/full_view/11},
\url{https://github.com/mxmssh/IDAmetrics} (incl. other metrics).

Plugin GCC:
\url{https://github.com/ephox-gcc-plugins/cyclomatic_complexity}.

