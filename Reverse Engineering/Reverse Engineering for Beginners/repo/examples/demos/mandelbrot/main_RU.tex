\clearpage
\subsection{Множество Мандельброта}
\label{Mandelbrot_demo}

В \MathForProg есть некоторые важные замечания о теории вокруг множества Мандельброта.

Вот демо\footnote{Можно скачать \href{http://www.pouet.net/prod.php?which=53287} {здесь},} 
написанное автором по имени \q{Sir\_Lagsalot} в 2009, 
рисующее множество Мандельброта, и это программа для x86 с размером файла всего 64 байта.
Там только 30 16-битных x86-инструкций.

Вот что она рисует:

\begin{figure}[H]
\centering
\myincludegraphics{examples/demos/mandelbrot/1.png}
\end{figure}

Попробуем разобраться, как она работает.

Демо, хотя и крошечная (только 64 байта или 30 инструкций), реализует общий алгоритм, изложенный
здесь, но с некоторыми трюками.

Исходный код можно скачать, так что вот он, но также снабдим его своими комментариями:

\lstinputlisting[caption=Исходный код с комментариями,numbers=left,style=customasmx86]{examples/demos/mandelbrot/Microbrot_commented_RU.asm}

Алгоритм:

\begin{itemize}
\item Переключаемся в режим VGA 320*200 256 цветов. 
$320*200=64000$ (0xFA00). 
Каждый пиксель кодируется одним байтом, так что размер буфера 0xFA00 байт.

Он адресуется здесь при помощи пары регистров ES:DI.

\myindex{x86!\Registers!ES}
ES должен быть здесь 0xA000, потому что это сегментный адрес видеобуфера, но запись
числа 0xA000 в ES потребует по крайней мере 4 байта (\TT{PUSH 0A000h / POP ES}). 
О 16-битной модели памяти в MS-DOS, читайте больше тут: 
\myref{8086_memory_model}.

\myindex{x86!\Instructions!LES}
Учитывая, что BX здесь 0, и Program Segment Prefix находится по нулевому адресу, 2-байтная инструкция
\TT{LES AX,[BX]} запишет 0x20CD в AX и 0x9FFF в ES.

Так что программа начнет рисовать на 16 пикселей (или байт) перед видеобуфером.

Но это MS-DOS, 
здесь нет защиты памяти, так что запись происходит в самый конец обычной памяти, а там, как правило, ничего важного нет.

Вот почему вы видите красную полосу шириной 16 пикселей справа.
Вся картинка сдвинута налево на 16 пикселей.
Это цена экономии 2-х байт.

\item Вечный цикл, обрабатывающий каждый пиксель.
Наверное, самый общий метод обойти все точки на экране это два цикла:
один для X-координаты, второй для Y-координаты.

Но тогда вам придется перемножать координаты для поиска байта в видеобуфере VGA.
Автор этого демо решил сделать наоборот: перебирать все байты в видеобуфере при помощи одного цикла
вместо двух и затем получать координаты текущей точки при помощи деления.

В итоге координаты такие: X в пределах $-256..63$ и Y 
в пределах $-100..99$.
Вы можете увидеть на скриншоте что картинка как бы сдвинута в правую часть экрана.
Это потому что самая большая черная дыра в форме сердца обычно появляется на координатах 0,0 и они
здесь сдвинуты вправо.

Мог ли автор просто отнять 160 от X, чтобы получилось значение в пределах $-160..159$? 
Да, но инструкция \TT{SUB DX, 160} занимает 4 байта, 
тогда как \TT{DEC DH} --- 2 байта 
(которая отнимает 0x100 (256) от DX). 
Так что картинка сдвинута ценой экономии еще 2-х байт.

    \begin{itemize}
    \item Проверить, является ли текущая точка внутри множества Мандельброта.
          Алгоритм такой же, как и описанный здесь.
\myindex{x86!\Instructions!LOOP}
     \item Цикл организуется инструкцией \TT{LOOP}, которая использует регистр CX как счетчик.
Автор мог бы установить число итераций на какое-то число, но не сделал этого: потому что 320 уже
находится в CX (было установлено на строке 35), и это итак подходящее число как число максимальных
итераций.

Мы здесь экономим немного места, не загружая другое значение в регистр CX.

\myindex{x86!\Instructions!SAR}
     \item Здесь используется \TT{IMUL} вместо \TT{MUL}, потому что мы работаем со знаковыми значениями:
помните, что координаты 0,0 должны быть где-то рядом с центром экрана.

Тоже самое и с \TT{SAR} (арифметический сдвиг для знаковых значений): она используется вместо \TT{SHR}.

     \item Еще одна идея --- это упростить проверку пределов.
Нам бы пришлось проверять пару координат, т.е. две переменных.
Что делает автор это трижды проверяет на переполнение: две операции возведения в квадрат и одно 
прибавление.
Действительно, мы ведь используем 16-битные регистры, содержащие знаковые значения в пределах
 -32768..32767, так что
если любая из координат больше чем 32767 в процессе умножения, точка однозначно вышла за пределы,
и мы переходим на метку \TT{MandelBreak}.

     \item Здесь также имеется деление на 64 (при помощи инструкции SAR). 64 задает масштаб.

Попробуйте увеличить значение и вы получите более увеличенную картинку, или уменьшить для
меньшей.

    \end{itemize}

\item Мы находимся на метке \TT{MandelBreak}, есть только две возможности
попасть сюда: 
цикл закончился с CX=0 (точка внутри множества Мандельброта
); или потому что произошло переполнение (CX все еще содержит 
какое-то значение).
Записываем 8-битную часть CX (CL) в видеобуфер.
Палитра по умолчанию грубая, тем не менее, 0 это черный: поэтому видим черные дыры в местах где точки
внутри множества Мандельброта.

Палитру можно инициализировать в начале программы, но не забывайте, это всего лишь программа на 64 
байта!

\item Программа работает в вечном цикле, потому что дополнительная проверка, где остановится, 
или пользовательский интерфейс, это дополнительные инструкции.

\end{itemize}

Еще оптимизационные трюки:

\myindex{x86!\Instructions!CWD}
\begin{itemize}
\item 1-байтная CWD используется здесь для обнуления DX вместо двухбайтной \TT{XOR DX, DX} или даже трехбайтной \TT{MOV DX, 0}.

\item 1-байтная \TT{XCHG AX, CX} используется вместо двухбайтной 
\TT{MOV AX,CX}. 
Текущее значение в AX все равно уже не нужно.

\item DI (позиция в видеобуфере) не инициализирована, и будет 0xFFFE в
начале
\footnote{Больше о состояниях регистров на старте: 
\url{https://code.google.com/p/corkami/wiki/InitialValues#DOS}}.
Это нормально, потому что программа работает бесконечно для всех DI в пределах 0..0xFFFF, и пользователь
не может увидеть, что работала началась за экраном (последний пиксель видеобуфера 320*200 имеет адрес 0xF9FF).

Так что некоторая часть работы на самом деле происходит за экраном.
А иначе понадобятся дополнительные инструкции для установки DI в 0; добавить проверку на конец буфера.

\end{itemize}

\newcommand{\MyFixedVersion}{Моя \q{исправленная} версия}
\subsubsection{\MyFixedVersion}

\lstinputlisting[caption=\MyFixedVersion,numbers=left,style=customasmx86]{examples/demos/mandelbrot/my_version_RU.asm}

Автор сих строк попытался исправить все эти странности: теперь палитра плавная черно-белая, видеобуфер на правильном месте
(строки 19..20), картинка рисуется в центре экрана (строка 30), программа в итоге заканчивается и ждет,
пока пользователь нажмет какую-нибудь клавишу (строки 58..68).

Но теперь она намного больше: 105 байт (или 54 инструкции)

\footnote{Можете поэкспериментировать и сами: скачайте DosBox и NASM и компилируйте так:
 
\TT{nasm file.asm -fbin -o file.com}}.

\begin{figure}[H]
\centering
\myincludegraphics{examples/demos/mandelbrot/fixed.png}
\caption{\MyFixedVersion}
\label{fig:mandelbrot_fixed}
\end{figure}

Смотрите также: маленькая программа на Си печатающая множество Мандельброта в ASCII:
\url{https://people.sc.fsu.edu/~jburkardt/c_src/mandelbrot_ascii/mandelbrot_ascii.html} \\
\url{https://miyuki.github.io/2017/10/04/gcc-archaeology-1.html}.

